#include <clock.h>
#include <console.h>
#include <defs.h>
#include <intr.h>
#include <kdebug.h>
#include <kmonitor.h>
#include <pmm.h>
#include <stdio.h>
#include <string.h>
#include <trap.h>
#include <dtb.h>

/* ======================================================================================
 * init.c - 内核初始化代码
 *
 * 这个文件包含了ucore操作系统内核的初始化序列
 * 初始化过程按照特定的顺序执行，确保系统各组件正确启动
 *
 * 初始化顺序的重要性：
 * 1. 内存和设备初始化必须在中断使能之前完成
 * 2. 中断处理程序必须在中断使能之前设置好
 * 3. 内存管理必须在其他组件之前初始化
 * ====================================================================================== */

int kern_init(void) __attribute__((noreturn));  // 内核初始化函数，不会返回
void grade_backtrace(void);                     // 用于评分的反向跟踪函数

/* ======================================================================================
 * kern_init - 内核主初始化函数
 *
 * 这个函数是内核的入口点，负责初始化所有内核子系统
 * 初始化完成后进入空闲循环，等待中断驱动的事件
 *
 * 初始化序列：
 * 1. 清除BSS段 - 确保未初始化的全局变量为0
 * 2. DTB初始化 - 解析设备树，获取硬件信息
 * 3. 控制台初始化 - 设置串口输出
 * 4. 内核信息打印 - 显示内存布局等信息
 * 5. 中断初始化 - 设置trap处理向量
 * 6. 物理内存管理初始化 - 设置页表和内存分配器
 * 7. 时钟初始化 - 设置定时器中断
 * 8. 启用中断 - 允许中断发生
 * ====================================================================================== */
int kern_init(void) {
    /* =================================================================================
     * 第一阶段：基础设置
     * ================================================================================= */

    extern char edata[], end[];
    /* 清除BSS段（未初始化的全局变量区域）
     * edata是数据段结束，end是BSS段结束
     * 确保所有未初始化的全局变量都被设置为0
     */
    memset(edata, 0, end - edata);

    /* 初始化设备树
     * 从DTB（Device Tree Blob）中解析系统硬件信息
     * 包括内存布局、设备信息等
     */
    dtb_init();

    /* 初始化控制台设备
     * 设置串口作为内核的输入输出设备
     * 必须在cprintf等函数使用前完成
     */
    cons_init();

    /* 显示系统启动信息 */
    const char *message = "(THU.CST) os is loading ...\0";
    cputs(message);  // 使用cputs而不是cprintf，因为printf可能还没完全初始化

    /* 打印内核内存布局信息 */
    print_kerninfo();

    /* =================================================================================
     * 第二阶段：核心子系统初始化
     * ================================================================================= */

    /* 第一次中断初始化 - 设置异常/中断处理向量
     * 必须在其他可能触发异常的操作之前完成
     * 设置stvec和sscratch等CSR
     */
    idt_init();

    /* 初始化物理内存管理
     * 设置页表、内存分配器等
     * 这是最复杂的初始化步骤之一
     */
    pmm_init();

    /* =================================================================================
     * 注意：这里再次调用idt_init()
     * ================================================================================= */
    /* 第二次中断初始化
     * 为什么需要再次调用？可能是因为pmm_init()中的某些操作
     * 覆盖了之前的中断设置，或者需要基于新的内存布局重新设置
     *
     * 这可能是一个需要注意的设计问题，在生产代码中应该避免重复初始化
     */
    idt_init();

    /* =================================================================================
     * 第三阶段：设备和中断使能
     * ================================================================================= */

    /* 初始化时钟中断系统
     * 设置定时器中断，为系统提供时间基准
     * 这会启动周期性的时钟中断
     */
    clock_init();

    /* 启用硬件中断
     * 到此时，所有中断处理程序都已设置完成
     * 系统现在可以响应中断事件
     */
    intr_enable();

    /* =================================================================================
     * 初始化完成，进入空闲循环
     * ================================================================================= */

    /* 内核初始化完成，进入无限循环
     * 系统现在由中断驱动，不会执行到这里
     * 如果执行到这里，说明系统出现问题
     */
    while (1)
        ;  // 空循环，等待中断
}

void __attribute__((noinline))
grade_backtrace2(int arg0, int arg1, int arg2, int arg3) {
    mon_backtrace(0, NULL, NULL);
}

void __attribute__((noinline)) grade_backtrace1(int arg0, int arg1) {
    grade_backtrace2(arg0, (uintptr_t)&arg0, arg1, (uintptr_t)&arg1);
}

void __attribute__((noinline)) grade_backtrace0(int arg0, int arg1, int arg2) {
    grade_backtrace1(arg0, arg2);
}

void grade_backtrace(void) { grade_backtrace0(0, (uintptr_t)kern_init, 0xffff0000); }

