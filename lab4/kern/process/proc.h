/**
 * @file kern/process/proc.h
 * @brief 进程管理核心数据结构和接口定义
 *
 * 本头文件定义了ucore操作系统中进程管理的所有核心数据结构和接口函数声明。
 * 包括进程状态、进程结构体、上下文结构体以及进程管理相关的所有函数原型。
 */

#ifndef __KERN_PROCESS_PROC_H__
#define __KERN_PROCESS_PROC_H__

#include <defs.h>       // 基本类型定义
#include <list.h>       // 双向链表
#include <trap.h>       // 中断和trapframe
#include <memlayout.h>  // 内存布局定义

// ============================================================================
// 进程状态定义
// ============================================================================

/**
 * @brief 进程状态枚举 - 定义进程生命周期的所有阶段
 *
 * 进程状态是操作系统进程管理的基础概念，描述了进程在执行过程中可能处于的不同状态。
 * 这些状态不仅反映了进程的当前状况，还控制着进程的调度行为和生命周期管理。
 *
 * ============================================================================
 * 进程状态机详解
 * ============================================================================
 *
 * PROC_UNINIT (未初始化)：
 *   - 状态值：0
 *   - 含义：进程刚刚被创建，数据结构已分配但未完全初始化
 *   - 进入时机：调用alloc_proc()后
 *   - 调度行为：不能被调度执行
 *   - 状态转换：只能转换为PROC_RUNNABLE（通过proc_init完成初始化）
 *
 * PROC_SLEEPING (睡眠/阻塞)：
 *   - 状态值：1
 *   - 含义：进程等待某些条件满足，无法继续执行
 *   - 进入时机：主动调用sleep()或等待资源时
 *   - 调度行为：不会被调度器选中
 *   - 状态转换：通过wakeup_proc()转换为PROC_RUNNABLE
 *
 * PROC_RUNNABLE (可运行/就绪)：
 *   - 状态值：2
 *   - 含义：进程已准备好执行，只等待CPU调度
 *   - 进入时机：进程创建完成，或从睡眠中被唤醒
 *   - 调度行为：可以被调度器选中并执行
 *   - 状态转换：被调度器选中时转换为运行状态（但状态仍为PROC_RUNNABLE）
 *
 * PROC_ZOMBIE (僵尸/终止)：
 *   - 状态值：3
 *   - 含义：进程已执行完毕，但资源尚未被父进程回收
 *   - 进入时机：进程调用exit()或执行完毕
 *   - 调度行为：不会被调度器选中
 *   - 状态转换：父进程调用wait()回收资源后，进程被销毁
 *
 * ============================================================================
 * 状态转换图
 * ============================================================================
 *
 * 创建进程：alloc_proc() -> PROC_UNINIT -> proc_init() -> PROC_RUNNABLE
 *
 * 正常执行：PROC_RUNNABLE -> [被调度执行] -> PROC_RUNNABLE -> ...
 *
 * 等待资源：PROC_RUNNABLE -> sleep() -> PROC_SLEEPING -> wakeup_proc() -> PROC_RUNNABLE
 *
 * 进程退出：PROC_RUNNABLE -> do_exit() -> PROC_ZOMBIE -> [父进程wait()] -> 销毁
 *
 * ============================================================================
 * 状态设计原则
 * ============================================================================
 *
 * 1. 互斥性：进程在任何时刻只能处于一种状态
 * 2. 完整性：覆盖了进程生命周期的所有阶段
 * 3. 调度相关：状态直接影响进程是否可以被调度
 * 4. 资源管理：状态转换伴随着资源的分配和释放
 */
enum proc_state
{
    PROC_UNINIT = 0,  /**< 未初始化状态：进程刚被创建，还未完全设置 */
    PROC_SLEEPING,    /**< 睡眠状态：等待某些事件或资源，无法被调度执行 */
    PROC_RUNNABLE,    /**< 可运行状态：准备执行或正在CPU上执行 */
    PROC_ZOMBIE,      /**< 僵尸状态：进程已终止，等待父进程回收其资源 */
};

/**
 * @brief 进程上下文结构体
 *
 * 保存进程切换时需要保存的CPU寄存器状态。
 * 当进程被切换出CPU时，这些寄存器值被保存；
 * 当进程重新获得CPU时，这些值被恢复。
 */
struct context
{
    uintptr_t ra;   /**< 返回地址寄存器 (x1) */
    uintptr_t sp;   /**< 栈指针寄存器 (x2) */
    uintptr_t s0;   /**< 保存寄存器 s0 (x8) */
    uintptr_t s1;   /**< 保存寄存器 s1 (x9) */
    uintptr_t s2;   /**< 保存寄存器 s2 (x18) */
    uintptr_t s3;   /**< 保存寄存器 s3 (x19) */
    uintptr_t s4;   /**< 保存寄存器 s4 (x20) */
    uintptr_t s5;   /**< 保存寄存器 s5 (x21) */
    uintptr_t s6;   /**< 保存寄存器 s6 (x22) */
    uintptr_t s7;   /**< 保存寄存器 s7 (x23) */
    uintptr_t s8;   /**< 保存寄存器 s8 (x24) */
    uintptr_t s9;   /**< 保存寄存器 s9 (x25) */
    uintptr_t s10;  /**< 保存寄存器 s10 (x26) */
    uintptr_t s11;  /**< 保存寄存器 s11 (x27) */
};

// ============================================================================
// 常量定义
// ============================================================================

/** 进程名称最大长度（不包括结尾的'\0'） */
#define PROC_NAME_LEN               15

/** 系统支持的最大进程数 */
#define MAX_PROCESS                 4096

/** PID的最大值（MAX_PROCESS * 2，确保有足够的PID空间） */
#define MAX_PID                     (MAX_PROCESS * 2)

// ============================================================================
// 全局变量声明
// ============================================================================

/**
 * @brief 进程链表头节点
 *
 * 所有可调度的进程（除idle进程外）都链接在这个双向循环链表中。
 * 调度器通过遍历这个链表来选择下一个要执行的进程。
 */
extern list_entry_t proc_list;

/**
 * @brief 进程结构体定义 - 操作系统进程的核心数据结构
 *
 * 这是ucore操作系统中进程的核心数据结构，包含了进程运行所需的所有状态信息。
 * 进程是操作系统中最基本的执行单位，每个进程都对应一个proc_struct实例。
 * 这个结构体设计体现了操作系统进程管理的核心概念和机制。
 *
 * ============================================================================
 * 结构体设计原则
 * ============================================================================
 *
 * 1. 状态管理：记录进程当前状态和生命周期信息
 * 2. 资源管理：跟踪进程占用的各种系统资源
 * 3. 执行控制：保存进程执行所需的CPU状态
 * 4. 调度支持：提供调度器所需的链接和控制信息
 * 5. 调试支持：包含调试和监控所需的统计信息
 *
 * ============================================================================
 * 字段详细说明
 * ============================================================================
 */
struct proc_struct
{
    // ========== 进程状态和标识 - 进程的基本属性 ==========
    enum proc_state state;           /**< 进程当前状态（UNINIT/SLEEPING/RUNNABLE/ZOMBIE）*/
    int pid;                         /**< 进程ID：唯一标识符，0表示idle进程 */
    int runs;                        /**< 调度统计：进程被调度的次数，用于性能分析 */

    // ========== 内存管理 - 进程的地址空间 ==========
    uintptr_t kstack;                /**< 内核栈起始地址：进程在内核态执行时使用的栈 */
    uintptr_t pgdir;                 /**< 页目录基地址：进程虚拟地址空间的根页表 */

    // ========== 调度控制 - 调度器的控制信息 ==========
    volatile bool need_resched;      /**< 重新调度标志：true表示需要被调度器重新调度 */

    // ========== 进程关系 - 进程家族树 ==========
    struct proc_struct *parent;      /**< 父进程指针：创建该进程的进程 */

    // ========== 内存空间 - 用户空间管理 ==========
    struct mm_struct *mm;            /**< 内存管理结构体：描述用户空间布局（lab4中未使用）*/

    // ========== 执行上下文 - CPU状态保存 ==========
    struct context context;          /**< 进程上下文：保存/恢复进程切换时的CPU寄存器状态 */
    struct trapframe *tf;            /**< 中断帧指针：保存中断/异常发生时的完整CPU状态 */

    // ========== 进程属性 - 扩展属性 ==========
    uint32_t flags;                  /**< 进程标志位：各种控制标志的位图 */
    char name[PROC_NAME_LEN + 1];    /**< 进程名称：人类可读的进程标识符 */

    // ========== 链表节点 - 数据结构链接 ==========
    list_entry_t list_link;          /**< 调度链表节点：链接到全局进程链表，用于轮转调度 */
    list_entry_t hash_link;          /**< 哈希链表节点：链接到PID哈希表，用于快速查找 */
};

/**
 * ============================================================================
 * 进程结构体的内存布局和生命周期
 * ============================================================================
 *
 * 内存布局（从低地址到高地址）：
 * +-------------------+ <-- 结构体起始地址
 * | state, pid, runs |     状态和标识信息
 * +-------------------+
 * | kstack, pgdir    |     内存管理信息
 * +-------------------+
 * | need_resched     |     调度控制
 * +-------------------+
 * | parent, mm       |     进程关系和内存空间
 * +-------------------+
 * | context          |     执行上下文（所有寄存器）
 * +-------------------+
 * | tf, flags, name  |     中断帧和属性
 * +-------------------+
 * | list_link        |     链表节点
 * | hash_link        |     哈希节点
 * +-------------------+ <-- 结构体结束地址
 *
 * 生命周期：
 * 1. alloc_proc()：分配内存，初始化为PROC_UNINIT状态
 * 2. 填充各个字段，设置为PROC_RUNNABLE状态
 * 3. 被调度器选中执行，状态仍为PROC_RUNNABLE
 * 4. 可能进入PROC_SLEEPING状态等待资源
 * 5. 执行完毕后进入PROC_ZOMBIE状态
 * 6. 被父进程回收，结构体被释放
 *
 * ============================================================================
 * 关键设计决策
 * ============================================================================
 *
 * 1. 状态和标识放在开头：最常访问的信息
 * 2. 上下文信息连续存放：进程切换时需要连续访问
 * 3. 链表节点放在末尾：链接操作相对较少
 * 4. 固定大小结构体：简化内存管理和分配
 * 5. 指针字段分离：区分不同类型的资源管理
 */

/**
 * @brief 将链表节点转换为进程结构体指针
 *
 * 这是一个常用的宏，用于从链表节点获得包含该节点的进程结构体地址。
 * @param le 链表节点指针
 * @param member 进程结构体中链表节点的成员名
 */
#define le2proc(le, member) \
    to_struct((le), struct proc_struct, member)

// ============================================================================
// 全局进程指针声明
// ============================================================================

extern struct proc_struct *idleproc;   /**< 空闲进程（PID=0）*/
extern struct proc_struct *initproc;   /**< 初始化进程（PID=1）*/
extern struct proc_struct *current;    /**< 当前正在执行的进程 */

// ============================================================================
// 函数声明
// ============================================================================

// ========== 进程系统初始化 ==========
void proc_init(void);  /**< 初始化进程管理系统 */

// ========== 进程调度和切换 ==========
void proc_run(struct proc_struct *proc);  /**< 切换到指定进程执行 */

// ========== 进程创建 ==========
int kernel_thread(int (*fn)(void *), void *arg, uint32_t clone_flags);
                                      /**< 创建内核线程 */
int do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf);
                                      /**< 创建新进程（核心函数）*/

// ========== 进程属性管理 ==========
char *set_proc_name(struct proc_struct *proc, const char *name);
                                      /**< 设置进程名称 */
char *get_proc_name(struct proc_struct *proc);
                                      /**< 获取进程名称 */

// ========== 进程查找 ==========
struct proc_struct *find_proc(int pid);  /**< 根据PID查找进程 */

// ========== 进程退出 ==========
int do_exit(int error_code);  /**< 终止当前进程 */

// ========== CPU空闲处理 ==========
void cpu_idle(void) __attribute__((noreturn));
                                      /**< CPU空闲循环 */

#endif /* !__KERN_PROCESS_PROC_H__ */
