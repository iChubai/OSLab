#include <default_pmm.h>
#include <defs.h>
#include <error.h>
#include <kmalloc.h>
#include <memlayout.h>
#include <mmu.h>
#include <pmm.h>
#include <sbi.h>
#include <stdio.h>
#include <string.h>
#include <sync.h>
#include <vmm.h>
#include <riscv.h>
#include <dtb.h>

// virtual address of physical page array
struct Page *pages;
// amount of physical memory (in pages)
size_t npage = 0;
// The kernel image is mapped at VA=KERNBASE and PA=info.base
uint_t va_pa_offset;
// memory starts at 0x80000000 in RISC-V
const size_t nbase = DRAM_BASE / PGSIZE;

// virtual address of boot-time page directory
pde_t *boot_pgdir_va = NULL;
// physical address of boot-time page directory
uintptr_t boot_pgdir_pa;

// physical memory management
const struct pmm_manager *pmm_manager;

static void check_alloc_page(void);
static void check_pgdir(void);
static void check_boot_pgdir(void);

// init_pmm_manager - initialize a pmm_manager instance
static void init_pmm_manager(void)
{
    pmm_manager = &default_pmm_manager;
    cprintf("memory management: %s\n", pmm_manager->name);
    pmm_manager->init();
}

// init_memmap - call pmm->init_memmap to build Page struct for free memory
static void init_memmap(struct Page *base, size_t n)
{
    pmm_manager->init_memmap(base, n);
}

// alloc_pages - call pmm->alloc_pages to allocate a continuous n*PAGESIZE
// memory
struct Page *alloc_pages(size_t n)
{
    struct Page *page = NULL;
    bool intr_flag;
    local_intr_save(intr_flag);
    {
        page = pmm_manager->alloc_pages(n);
    }
    local_intr_restore(intr_flag);
    return page;
}

// free_pages - call pmm->free_pages to free a continuous n*PAGESIZE memory
void free_pages(struct Page *base, size_t n)
{
    bool intr_flag;
    local_intr_save(intr_flag);
    {
        pmm_manager->free_pages(base, n);
    }
    local_intr_restore(intr_flag);
}

// nr_free_pages - call pmm->nr_free_pages to get the size (nr*PAGESIZE)
// of current free memory
size_t nr_free_pages(void)
{
    size_t ret;
    bool intr_flag;
    local_intr_save(intr_flag);
    {
        ret = pmm_manager->nr_free_pages();
    }
    local_intr_restore(intr_flag);
    return ret;
}

/* pmm_init - initialize the physical memory management */
static void page_init(void)
{
    extern char kern_entry[];

    va_pa_offset = PHYSICAL_MEMORY_OFFSET;

    uint64_t mem_begin = get_memory_base();
    uint64_t mem_size  = get_memory_size();
    if (mem_size == 0) {
        panic("DTB memory info not available");
    }
    uint64_t mem_end   = mem_begin + mem_size;

    cprintf("physcial memory map:\n");
    cprintf("  memory: 0x%08lx, [0x%08lx, 0x%08lx].\n", mem_size, mem_begin,
            mem_end - 1);

    uint64_t maxpa = mem_end;

    if (maxpa > KERNTOP)
    {
        maxpa = KERNTOP;
    }

    extern char end[];

    npage = maxpa / PGSIZE;
    // BBL has put the initial page table at the first available page after the
    // kernel
    // so stay away from it by adding extra offset to end
    pages = (struct Page *)ROUNDUP((void *)end, PGSIZE);

    for (size_t i = 0; i < npage - nbase; i++)
    {
        SetPageReserved(pages + i);
    }

    uintptr_t freemem = PADDR((uintptr_t)pages + sizeof(struct Page) * (npage - nbase));

    mem_begin = ROUNDUP(freemem, PGSIZE);
    mem_end = ROUNDDOWN(mem_end, PGSIZE);
    if (freemem < mem_end)
    {
        init_memmap(pa2page(mem_begin), (mem_end - mem_begin) / PGSIZE);
    }
    cprintf("vapaofset is %llu\n", va_pa_offset);
}
static void enable_paging(void)
{
    write_csr(satp, 0x8000000000000000 | (boot_pgdir_pa >> RISCV_PGSHIFT));
}

/**
 * @brief 建立启动时的页表映射段
 *
 * 这个函数是系统启动阶段的关键函数，用于建立内核的初始页表映射。
 * 在分页机制启用之前，系统需要预先建立好基本的内存映射关系。
 *
 * ============================================================================
 * 启动时内存映射的重要性
 * ============================================================================
 *
 * 在分页机制启用前，CPU使用物理地址访问内存。
 * 一旦启用分页，CPU开始使用虚拟地址，所有内存访问都需要通过页表转换。
 *
 * 启动时必须建立的关键映射：
 * 1. **内核代码段**：确保内核代码可以继续执行
 * 2. **内核数据段**：确保内核数据可以访问
 * 3. **内核栈**：确保栈操作正常
 * 4. **设备内存**：确保I/O设备可以访问
 *
 * 如果启动时页表设置不正确，系统会立即崩溃。
 *
 * ============================================================================
 * 参数详解
 * ============================================================================
 *
 * @param pgdir  页目录基地址：目标页表
 * @param la     线性地址：虚拟地址起始点
 * @param size   内存大小：需要映射的内存大小
 * @param pa     物理地址：物理地址起始点
 * @param perm   权限标志：页表项的权限设置
 *
 * ============================================================================
 * 地址对齐要求
 * ============================================================================
 *
 * ```c
 * assert(PGOFF(la) == PGOFF(pa));
 * ```
 *
 * 这个断言确保虚拟地址和物理地址的页内偏移量相同：
 * - PGOFF(addr) = addr & (PGSIZE - 1)  // 提取页内偏移
 * - 例如：如果la = 0x1000, pa必须也是0x?000形式
 *
 * 原因：
 * - 页表映射是以页为单位的
 * - 同一个页内的相对偏移必须一致
 * - 避免复杂的页内地址转换
 *
 * ============================================================================
 * 映射范围计算
 * ============================================================================
 *
 * ```c
 * size_t n = ROUNDUP(size + PGOFF(la), PGSIZE) / PGSIZE;
 * ```
 *
 * 计算需要映射的页数：
 * 1. `size + PGOFF(la)`：考虑页内偏移的实际大小
 * 2. `ROUNDUP(..., PGSIZE)`：向上取整到页边界
 * 3. `/ PGSIZE`：转换为页数
 *
 * 示例：
 * - la = 0x1000, size = 0x2000
 * - PGOFF(la) = 0 (已在页边界)
 * - ROUNDUP(0x2000, 0x1000) = 0x2000
 * - 页数 = 0x2000 / 0x1000 = 2页
 *
 * ============================================================================
 * 地址对齐处理
 * ============================================================================
 *
 * ```c
 * la = ROUNDDOWN(la, PGSIZE);  // 对齐到页起始
 * pa = ROUNDDOWN(pa, PGSIZE);  // 对齐到页起始
 * ```
 *
 * 确保地址按页边界对齐，因为页表映射是以页为单位的。
 *
 * ============================================================================
 * 映射建立过程
 * ============================================================================
 *
 * 循环为每一页建立映射：
 * ```c
 * for (; n > 0; n--, la += PGSIZE, pa += PGSIZE) {
 *     pte_t *ptep = get_pte(pgdir, la, 1);  // 获取页表项
 *     assert(ptep != NULL);                 // 确保成功
 *     *ptep = pte_create(pa >> PGSHIFT, PTE_V | perm);  // 建立映射
 * }
 * ```
 *
 * 关键点：
 * - `get_pte(..., 1)`：允许分配中间页表
 * - `pa >> PGSHIFT`：物理地址转换为物理页号
 * - `PTE_V | perm`：有效位 + 用户指定权限
 *
 * ============================================================================
 * 与动态映射的区别
 * ============================================================================
 *
 * **启动时映射 (boot_map_segment)**：
 * - 在系统启动阶段执行
 * - 用于建立基本内存布局
 * - 映射关系相对固定
 * - 失败会导致系统崩溃
 *
 * **运行时映射 (page_insert)**：
 * - 在系统运行过程中调用
 * - 用于动态内存分配
 * - 处理映射冲突
 * - 有完善的错误处理
 *
 * ============================================================================
 * 权限设置考虑
 * ============================================================================
 *
 * perm 参数控制页面的访问权限：
 * - PTE_R：可读 (通常都设置)
 * - PTE_W：可写 (数据段需要)
 * - PTE_X：可执行 (代码段需要)
 * - PTE_U：用户态可访问 (内核段通常不设置)
 *
 * 内核页面的典型权限：
 * - 代码段：PTE_R | PTE_X (可读可执行)
 * - 数据段：PTE_R | PTE_W (可读可写)
 * - 只读数据：PTE_R (只读)
 */
static void boot_map_segment(pde_t *pgdir, uintptr_t la, size_t size,
                             uintptr_t pa, uint32_t perm)
{
    // ========================================================================
    // 参数验证：确保地址对齐
    // ========================================================================
    // 虚拟地址和物理地址的页内偏移必须相同
    // 这确保了映射关系的正确性
    assert(PGOFF(la) == PGOFF(pa));

    // ========================================================================
    // 计算需要映射的页数
    // ========================================================================
    // ROUNDUP(size + PGOFF(la), PGSIZE) 计算实际需要的字节数
    // 然后除以页大小得到页数
    size_t n = ROUNDUP(size + PGOFF(la), PGSIZE) / PGSIZE;

    // ========================================================================
    // 对齐地址到页边界
    // ========================================================================
    // 页表映射是以页为单位，必须从页边界开始
    la = ROUNDDOWN(la, PGSIZE);
    pa = ROUNDDOWN(pa, PGSIZE);

    // ========================================================================
    // 为每一页建立映射
    // ========================================================================
    for (; n > 0; n--, la += PGSIZE, pa += PGSIZE)
    {
        // 获取目标虚拟地址的页表项，允许分配中间页表
        pte_t *ptep = get_pte(pgdir, la, 1);

        // 启动时映射必须成功，否则系统无法正常工作
        assert(ptep != NULL);

        // 建立映射：物理页号 + 有效位 + 权限标志
        // pa >> PGSHIFT 将物理地址转换为物理页号
        *ptep = pte_create(pa >> PGSHIFT, PTE_V | perm);
    }
}

// boot_alloc_page - allocate one page using pmm->alloc_pages(1)
// return value: the kernel virtual address of this allocated page
// note: this function is used to get the memory for PDT(Page Directory
// Table)&PT(Page Table)
static void *boot_alloc_page(void)
{
    struct Page *p = alloc_page();
    if (p == NULL)
    {
        panic("boot_alloc_page failed.\n");
    }
    return page2kva(p);
}

/**
 * @brief 初始化物理内存管理和分页机制
 *
 * 这是操作系统内存子系统的核心初始化函数，负责建立完整的内存管理框架。
 * 该函数执行后，系统具备了物理内存分配、虚拟内存映射和分页保护的能力。
 *
 * ============================================================================
 * 初始化流程总览
 * ============================================================================
 *
 * 1. **物理内存管理器初始化**：建立物理页分配机制
 * 2. **内存检测和标记**：识别可用物理内存，建立页描述符数组
 * 3. **页分配功能验证**：确保物理内存分配器工作正常
 * 4. **页表初始化**：设置内核的初始页目录和页表
 * 5. **页表结构验证**：检查页目录和页表的基本功能
 * 6. **虚拟内存映射验证**：确认内核的虚拟地址空间正确建立
 * 7. **内核堆初始化**：为内核动态内存分配做准备
 *
 * ============================================================================
 * 详细执行流程
 * ============================================================================
 */
void pmm_init(void)
{
    // ========================================================================
    // 第一阶段：物理内存管理器初始化
    // ========================================================================
    // 初始化物理内存管理器框架
    // ucore支持多种内存分配算法：first_fit, best_fit, worst_fit, buddy_system
    // 这里选择默认的内存管理器（通常是first_fit）
    init_pmm_manager();

    // ========================================================================
    // 第二阶段：物理内存检测和页描述符初始化
    // ========================================================================
    // 检测系统中的物理内存空间
    // 建立Page结构体数组，用于跟踪每一页物理内存的状态
    // 标记已使用的内存区域（内核代码、数据、已分配页面等）
    page_init();

    // ========================================================================
    // 第三阶段：物理内存分配功能验证
    // ========================================================================
    // 通过一系列测试验证物理内存分配器的正确性
    // 包括分配、释放、边界条件等场景的测试
    check_alloc_page();

    // ========================================================================
    // 第四阶段：内核页表初始化
    // ========================================================================
    // 设置内核的初始页目录表（Page Directory Table）
    // boot_page_table_sv39是由汇编代码预定义的初始页表
    // 它包含了内核启动所需的基本映射关系
    extern char boot_page_table_sv39[];
    boot_pgdir_va = (pte_t *)boot_page_table_sv39;     // 虚拟地址
    boot_pgdir_pa = PADDR(boot_pgdir_va);              // 物理地址

    // ========================================================================
    // 第五阶段：页表结构功能验证
    // ========================================================================
    // 验证页目录表和页表的基本操作
    // 测试get_pte, page_insert, page_remove等函数
    check_pgdir();

    // ========================================================================
    // 第六阶段：虚拟内存映射验证
    // ========================================================================
    // 验证内核虚拟地址空间的正确性
    // 检查内核代码段、数据段、栈等关键区域的映射
    // 确保分页机制启用后内核能正常运行
    check_boot_pgdir();

    // ========================================================================
    // 第七阶段：内核动态内存分配初始化
    // ========================================================================
    // 初始化内核堆管理器，为kmalloc/kfree等函数做准备
    // 内核可以使用kmalloc分配小块内存，使用页分配器分配大块内存
    kmalloc_init();
}

/**
 * ============================================================================
 * 内存管理子系统的层次结构
 * ============================================================================
 *
 * **物理内存管理层**：
 * - 物理页分配器 (pmm_manager)：管理物理页面的分配和释放
 * - Page结构体数组：跟踪每一页的状态和引用计数
 * - 内存检测：识别可用物理内存范围
 *
 * **虚拟内存管理层**：
 * - 页表操作：get_pte, page_insert, page_remove等
 * - 地址映射：虚拟地址到物理地址的转换
 * - 内存保护：通过页表权限位实现访问控制
 *
 * **内核内存分配层**：
 * - kmalloc：小块内存分配（<页面大小）
 * - 页分配器：大块内存分配（页面级）
 *
 * ============================================================================
 * 关键数据结构
 * ============================================================================
 *
 * - pages[]：物理页描述符数组，每个Page对应一页物理内存
 * - boot_pgdir_va：内核页目录的虚拟地址
 * - boot_pgdir_pa：内核页目录的物理地址
 * - pmm_manager：物理内存管理器的函数指针表
 *
 * ============================================================================
 * 安全性和正确性保证
 * ============================================================================
 *
 * 1. **内存泄漏防护**：通过引用计数确保页面被正确释放
 * 2. **地址空间隔离**：不同进程有独立的页表
 * 3. **权限控制**：页表项包含读写执行权限
 * 4. **错误检测**：多重验证确保映射关系正确
 * 5. **原子性操作**：关键操作使用中断屏蔽保证原子性
 *
 * ============================================================================
 * 与后续实验的关系
 * ============================================================================
 *
 * lab4建立了基本的虚拟内存框架，后续实验在此基础上扩展：
 * - lab5：用户进程和地址空间
 * - lab6：进程间通信和文件系统
 * - lab7：完整的虚拟内存管理（页面置换、共享内存等）
 */

/**
 * @brief 获取或创建页表项 (Page Table Entry)
 *
 * 这是虚拟内存管理系统的核心函数之一，实现从虚拟地址到页表项的查找和创建。
 * 该函数处理多级页表的遍历，并在需要时分配中间页表。
 *
 * ============================================================================
 * 虚拟地址到物理地址的映射过程
 * ============================================================================
 *
 * 在分页系统中，虚拟地址(VA)到物理地址(PA)的转换需要通过多级页表：
 *
 * 1. 虚拟地址格式 (RISC-V SV39, 39位虚拟地址):
 *    +-----------------------------------+
 *    | VPN[2] | VPN[1] | VPN[0] | OFFSET |
 *    +-----------------------------------+
 *      9位      9位      9位      12位
 *
 * 2. 页表层次结构:
 *    根页表 (Level 2) -> 中间页表 (Level 1) -> 末级页表 (Level 0)
 *    pgdir              pdep1               pdep0
 *
 * 3. 查找过程:
 *    VA -> 根页表[VPN[2]] -> 中间页表[VPN[1]] -> 末级页表[VPN[0]]
 *
 * ============================================================================
 * 函数参数详解
 * ============================================================================
 *
 * @param pgdir  页目录基地址：指向根页表的内核虚拟地址
 *               这是整个页表系统的入口点
 *
 * @param la     线性地址：需要映射的虚拟地址 (linear address)
 *               函数将从这个地址的VPN[2]开始向下查找
 *
 * @param create 创建标志：决定是否分配缺失的中间页表
 *               - true: 如果中间页表不存在，会分配新的物理页
 *               - false: 只进行查找，不进行分配
 *
 * @return       页表项的内核虚拟地址，如果失败返回NULL
 *
 * ============================================================================
 * 错误处理策略
 * ============================================================================
 *
 * - 如果create=false且中间页表不存在：返回NULL
 * - 如果create=true但内存分配失败：返回NULL
 * - 成功时返回末级页表中对应VPN[0]的页表项地址
 *
 * ============================================================================
 * 与物理内存管理的交互
 * ============================================================================
 *
 * 该函数调用物理内存管理器:
 * - alloc_page(): 分配物理页作为新的页表
 * - page2pa()/page2ppn(): 地址转换
 * - KADDR(): 物理地址到内核虚拟地址转换
 */
pte_t *get_pte(pde_t *pgdir, uintptr_t la, bool create)
{
    // ============================================================================
    // 第一级页表查找：根页表 -> 中间页表 (Level 2 -> Level 1)
    // ============================================================================
    // 计算根页表中的索引：PDX1(la) 提取 VPN[2] (虚拟页号的最高9位)
    pde_t *pdep1 = &pgdir[PDX1(la)];

    // 检查一级页表项是否有效 (PTE_V = Valid 位)
    if (!(*pdep1 & PTE_V))
    {
        // ========================================================================
        // 中间页表不存在，需要分配新的物理页作为二级页表
        // ========================================================================
        struct Page *page;

        // 检查是否允许创建页表，以及内存分配是否成功
        if (!create || (page = alloc_page()) == NULL)
        {
            // create=false 或内存不足，返回NULL表示失败
            return NULL;
        }

        // 设置页引用计数：页表页的引用计数为1
        set_page_ref(page, 1);

        // 获取物理页的物理地址
        uintptr_t pa = page2pa(page);

        // 清空新分配的页表页：确保所有页表项初始为0 (无效)
        memset(KADDR(pa), 0, PGSIZE);

        // 创建页表项：指向新分配的页表页
        // PTE_U | PTE_V：用户可访问 + 有效位
        *pdep1 = pte_create(page2ppn(page), PTE_U | PTE_V);
    }

    // ============================================================================
    // 第二级页表查找：中间页表 -> 末级页表 (Level 1 -> Level 0)
    // ============================================================================
    // 从一级页表项中提取中间页表的基地址：PDE_ADDR(*pdep1)
    // 然后计算二级页表中的索引：PDX0(la) 提取 VPN[1]
    pde_t *pdep0 = &((pte_t *)KADDR(PDE_ADDR(*pdep1)))[PDX0(la)];

    // 检查二级页表项是否有效
    if (!(*pdep0 & PTE_V))
    {
        // ========================================================================
        // 末级页表不存在，需要分配新的物理页作为三级页表
        // ========================================================================
        struct Page *page;

        // 检查是否允许创建页表，以及内存分配是否成功
        if (!create || (page = alloc_page()) == NULL)
        {
            // create=false 或内存不足，返回NULL表示失败
            return NULL;
        }

        // 设置页引用计数：页表页的引用计数为1
        set_page_ref(page, 1);

        // 获取物理页的物理地址
        uintptr_t pa = page2pa(page);

        // 清空新分配的页表页：确保所有页表项初始为0
        memset(KADDR(pa), 0, PGSIZE);

        // 创建页表项：指向新分配的页表页
        // PTE_U | PTE_V：用户可访问 + 有效位
        *pdep0 = pte_create(page2ppn(page), PTE_U | PTE_V);
    }

    // ============================================================================
    // 返回末级页表中的页表项地址 (Level 0 PTE)
    // ============================================================================
    // 从二级页表项中提取末级页表的基地址：PDE_ADDR(*pdep0)
    // 然后计算末级页表中的索引：PTX(la) 提取 VPN[0]
    // 返回最终页表项的内核虚拟地址
    return &((pte_t *)KADDR(PDE_ADDR(*pdep0)))[PTX(la)];
}

/**
 * @brief 根据虚拟地址获取对应的物理页结构体
 *
 * 这个函数是虚拟内存系统的重要接口，用于将虚拟地址映射回对应的物理页。
 * 它是页表查找的最终步骤，将页表项转换为Page结构体。
 *
 * ============================================================================
 * 虚拟地址到物理页的完整查找过程
 * ============================================================================
 *
 * 虚拟地址 (VA) → 页表查找 → 页表项 (PTE) → 物理页号 (PPN) → Page结构体
 *
 * 1. VA 通过 get_pte() 找到对应的页表项
 * 2. 页表项包含物理页号 (PPN)
 * 3. PPN 通过 pte2page() 转换为 Page 结构体指针
 * 4. Page 结构体包含物理页的管理信息
 *
 * ============================================================================
 * 函数参数详解
 * ============================================================================
 *
 * @param pgdir       页目录基地址：页表的根节点
 * @param la          线性地址：需要查找的虚拟地址
 * @param ptep_store  输出参数：如果不为NULL，用来存储找到的页表项地址
 *                    这是为了让调用者可以直接操作页表项
 *
 * @return            对应的Page结构体指针，失败返回NULL
 *
 * ============================================================================
 * 返回值含义
 * ============================================================================
 *
 * - 成功：返回有效的Page结构体指针，表示该虚拟地址已映射到物理页
 * - 失败(NULL)：虚拟地址未映射或页表项无效
 *
 * ============================================================================
 * ptep_store 参数的使用场景
 * ============================================================================
 *
 * 有些操作需要同时访问页表项和Page结构体：
 *
 * ```c
 * pte_t *ptep;
 * struct Page *page = get_page(pgdir, va, &ptep);
 * if (page != NULL) {
 *     // 同时有page和ptep，可以进行复杂的页操作
 *     // 比如修改权限、检查访问位等
 * }
 * ```
 *
 * ============================================================================
 * 与页表遍历的区别
 * ============================================================================
 *
 * - get_pte(): 只查找页表项本身，不关心映射关系
 * - get_page(): 查找完整的映射关系，返回物理页
 *
 * 这两个函数配合使用，提供了完整的虚拟内存查询功能。
 */
struct Page *get_page(pde_t *pgdir, uintptr_t la, pte_t **ptep_store)
{
    // ========================================================================
    // 第一步：查找页表项 (不分配新的页表)
    // ========================================================================
    // 调用get_pte()查找虚拟地址对应的页表项
    // create=0 表示只查找，不分配缺失的中间页表
    pte_t *ptep = get_pte(pgdir, la, 0);

    // ========================================================================
    // 第二步：存储页表项地址（如果需要）
    // ========================================================================
    // 如果调用者提供了ptep_store指针，将页表项地址存储起来
    // 这允许调用者直接操作页表项（比如修改权限位）
    if (ptep_store != NULL)
    {
        *ptep_store = ptep;
    }

    // ========================================================================
    // 第三步：验证映射有效性并返回物理页
    // ========================================================================
    // 检查页表项是否存在且有效 (PTE_V 位为1)
    if (ptep != NULL && *ptep & PTE_V)
    {
        // 从有效的页表项中提取物理页结构体
        // pte2page() 根据页表项中的PPN找到对应的Page结构体
        return pte2page(*ptep);
    }

    // 页表项不存在或无效，返回NULL表示映射不存在
    return NULL;
}

/**
 * @brief 解除页表项映射的底层实现函数
 *
 * 这是虚拟内存管理系统的底层函数，直接操作已知的页表项来解除映射关系。
 * 该函数处理物理页的引用计数管理和页表项的清理工作。
 *
 * ============================================================================
 * 函数执行的六个步骤
 * ============================================================================
 *
 * 1. **验证映射有效性**：检查页表项是否有效 (PTE_V 位)
 * 2. **查找物理页**：从页表项中提取对应的Page结构体
 * 3. **减少引用计数**：page_ref_dec() 减少物理页的引用计数
 * 4. **释放物理页**：如果引用计数为0，释放物理页回内存池
 * 5. **清除页表项**：将页表项设置为0（无效）
 * 6. **刷新TLB**：确保CPU不再使用已失效的映射
 *
 * ============================================================================
 * 参数详解
 * ============================================================================
 *
 * @param pgdir  页目录基地址：页表的根节点（用于TLB刷新）
 * @param la     线性地址：被解除映射的虚拟地址（用于TLB刷新）
 * @param ptep   页表项指针：指向需要解除的页表项
 *
 * ============================================================================
 * 引用计数管理机制
 * ============================================================================
 *
 * 物理页的生命周期完全由引用计数控制：
 *
 * ```c
 * // 建立映射时
 * page_ref_inc(page);  // 引用计数 +1
 *
 * // 解除映射时
 * page_ref_dec(page);  // 引用计数 -1
 * if (page_ref(page) == 0) {
 *     free_page(page);  // 引用计数为0，释放页面
 * }
 * ```
 *
 * 这个机制支持：
 * - **页面共享**：多个虚拟地址映射到同一物理页
 * - **内存复用**：只有当所有映射都解除时才释放物理页
 * - **内存安全**：防止过早释放仍在使用的页面
 *
 * ============================================================================
 * TLB 刷新重要性
 * ============================================================================
 *
 * 页表项清除后，必须刷新TLB，否则会发生：
 *
 * 1. **悬空指针问题**：CPU仍认为映射有效
 * 2. **内存访问错误**：访问已释放的物理内存
 * 3. **安全漏洞**：可能访问不属于当前进程的内存
 *
 * RISC-V 的 sfence.vma 指令会：
 * - 刷新指定地址的TLB条目
 * - 确保后续内存访问使用新的页表内容
 *
 * ============================================================================
 * 安全检查
 * ============================================================================
 *
 * 函数只处理有效的页表项：
 * ```c
 * if (*ptep & PTE_V) {
 *     // 只处理有效映射
 * } else {
 *     // 无效映射，安全跳过
 * }
 * ```
 *
 * 这样可以安全地对未映射的地址调用该函数。
 *
 * ============================================================================
 * 与page_remove的区别
 * ============================================================================
 *
 * - page_remove(): 需要先查找页表项，适用于高层调用
 * - page_remove_pte(): 直接操作已知的页表项，适用于底层实现
 *
 * page_remove() 内部调用 page_remove_pte() 来完成实际工作。
 *
 * ============================================================================
 * 性能考虑
 * ============================================================================
 *
 * 该函数是内存管理系统的热点路径，需要高效：
 * - 避免不必要的内存分配
 * - 最小化TLB刷新范围（使用sfence.vma而不是全局刷新）
 * - 内联函数形式减少函数调用开销
 */
static inline void page_remove_pte(pde_t *pgdir, uintptr_t la, pte_t *ptep)
{
    // ========================================================================
    // (1) 检查页表项是否有效
    // ========================================================================
    // 只有有效的页表项才需要解除映射
    // PTE_V (Valid) 位表示该页表项是否包含有效映射
    if (*ptep & PTE_V)
    {
        // ====================================================================
        // (2) 从页表项中提取对应的物理页结构体
        // ====================================================================
        // pte2page() 根据页表项中的物理页号找到对应的Page结构体
        // 这个Page结构体包含了物理页的管理信息（引用计数、状态等）
        struct Page *page = pte2page(*ptep);

        // ====================================================================
        // (3) 减少物理页的引用计数
        // ====================================================================
        // 解除一个映射关系，相应地减少物理页的引用计数
        // 这反映了该物理页被使用的虚拟地址减少了一个
        page_ref_dec(page);

        // ====================================================================
        // (4) 如果引用计数为0，释放物理页
        // ====================================================================
        // 当没有任何虚拟地址映射到该物理页时，释放它回内存池
        // 这确保了内存的高效复用，避免内存泄漏
        if (page_ref(page) == 0)
        {
            free_page(page);  // 释放物理页回空闲内存池
        }

        // ====================================================================
        // (5) 清除页表项
        // ====================================================================
        // 将页表项设置为0，表示该虚拟地址不再有效映射
        // 这断开了虚拟地址到物理地址的连接关系
        *ptep = 0;

        // ====================================================================
        // (6) 刷新TLB缓存
        // ====================================================================
        // 页表修改后必须刷新TLB，确保CPU不再使用已失效的映射
        // sfence.vma指令会刷新指定虚拟地址的TLB条目
        tlb_invalidate(pgdir, la);
    }

    // ========================================================================
    // 处理完成
    // ========================================================================
    // 如果页表项本来就无效，函数安全地不执行任何操作
}

/**
 * @brief 解除虚拟地址的页映射关系
 *
 * 这个函数是虚拟内存管理的逆操作，用于撤销虚拟地址到物理页的映射。
 * 它会减少相关物理页的引用计数，并在需要时释放物理内存。
 *
 * ============================================================================
 * 映射解除的完整流程
 * ============================================================================
 *
 * 1. 查找目标虚拟地址的页表项
 * 2. 如果映射存在，调用page_remove_pte()处理具体的解除操作
 * 3. page_remove_pte()会：
 *    - 验证映射有效性
 *    - 减少物理页引用计数
 *    - 清除页表项
 *    - 刷新TLB缓存
 *    - 在引用计数为0时释放物理页
 *
 * ============================================================================
 * 与page_remove_pte的区别
 * ============================================================================
 *
 * - page_remove(): 高层接口，需要先查找页表项
 * - page_remove_pte(): 底层实现，直接操作已知的页表项
 *
 * page_remove() 相当于：
 * ```c
 * pte_t *ptep = get_pte(pgdir, la, 0);
 * if (ptep != NULL) {
 *     page_remove_pte(pgdir, la, ptep);
 * }
 * ```
 *
 * ============================================================================
 * 参数和返回值
 * ============================================================================
 *
 * @param pgdir  页目录基地址：页表的根节点
 * @param la     线性地址：需要解除映射的虚拟地址
 *
 * @note 该函数没有返回值，也不报告错误
 * @note 如果地址未映射，该函数安全地不执行任何操作
 *
 * ============================================================================
 * 内存释放机制
 * ============================================================================
 *
 * 物理页的释放由引用计数决定：
 * - 每个映射都会增加页面的引用计数
 * - 解除映射会减少页面的引用计数
 * - 当引用计数降为0时，物理页被释放回空闲池
 *
 * 这确保了共享页面的正确管理（例如多个进程共享的代码段）。
 *
 * ============================================================================
 * TLB 处理
 * ============================================================================
 *
 * 映射解除后会刷新TLB，确保CPU不再使用已失效的映射。
 * 这防止了访问已释放内存的安全问题。
 *
 * ============================================================================
 * 使用场景
 * ============================================================================
 *
 * 1. 内存释放：free() 释放内存时解除映射
 * 2. 页面替换：页面置换算法选择牺牲页时
 * 3. 进程退出：清理进程地址空间时
 * 4. 内存整理：系统内存整理操作时
 */
void page_remove(pde_t *pgdir, uintptr_t la)
{
    // ========================================================================
    // 第一步：查找页表项
    // ========================================================================
    // 调用get_pte()查找虚拟地址对应的页表项
    // create=0表示只查找，不分配新的页表
    pte_t *ptep = get_pte(pgdir, la, 0);

    // ========================================================================
    // 第二步：如果页表项存在，解除映射
    // ========================================================================
    // 只有当页表项存在时才需要解除映射
    // 如果地址未映射，get_pte()返回NULL，这里直接跳过
    if (ptep != NULL)
    {
        // 调用底层函数page_remove_pte()执行实际的映射解除
        // 这个函数会处理引用计数、页表项清除、TLB刷新等
        page_remove_pte(pgdir, la, ptep);
    }

    // ========================================================================
    // 处理完成
    // ========================================================================
    // 如果页表项不存在，函数安全地不执行任何操作
}

/**
 * @brief 建立虚拟地址到物理页的映射关系
 *
 * 这是虚拟内存管理系统的核心功能之一，用于将虚拟地址映射到物理页。
 * 该函数处理映射冲突、权限设置、引用计数更新等复杂逻辑。
 *
 * ============================================================================
 * 映射建立的完整流程
 * ============================================================================
 *
 * 1. 查找目标虚拟地址的页表项
 * 2. 处理映射冲突（如果该地址已被映射）
 * 3. 更新页表项，建立新的映射
 * 4. 刷新TLB缓存，确保映射立即生效
 * 5. 更新页面引用计数
 *
 * ============================================================================
 * 参数详解
 * ============================================================================
 *
 * @param pgdir  页目录基地址：页表的根节点
 * @param page   目标物理页：要映射到的Page结构体
 * @param la     线性地址：虚拟地址，必须按页边界对齐
 * @param perm   权限标志：页表项的权限位组合
 *
 * 权限标志 (perm) 的可能值：
 * - PTE_V: Valid - 映射有效
 * - PTE_R: Readable - 可读
 * - PTE_W: Writable - 可写
 * - PTE_X: Executable - 可执行
 * - PTE_U: User - 用户态可访问
 *
 * ============================================================================
 * 映射冲突处理
 * ============================================================================
 *
 * 当虚拟地址已被映射时，需要：
 * 1. 找到当前的映射页 (pte2page)
 * 2. 如果是同一个页，只更新权限
 * 3. 如果是不同页，解除旧映射 (page_ref_dec)
 * 4. 如果旧页引用计数为0，释放物理页
 *
 * ============================================================================
 * TLB 刷新机制
 * ============================================================================
 *
 * 页表修改后必须刷新TLB (Translation Lookaside Buffer)：
 * - TLB 是页表的高速缓存，存储最近使用的地址映射
 * - 如果不刷新TLB，CPU可能仍使用旧的映射
 * - tlb_invalidate() 使用 sfence.vma 指令刷新特定地址的TLB
 *
 * ============================================================================
 * 引用计数管理
 * ============================================================================
 *
 * 物理页的生命周期由引用计数控制：
 * - 新映射建立：page_ref_inc(page)
 * - 旧映射解除：page_ref_dec(old_page)
 * - 引用计数为0：物理页可被回收
 *
 * ============================================================================
 * 错误处理
 * ============================================================================
 *
 * 可能的失败情况：
 * - 页表分配失败 (get_pte 返回NULL)
 * - 内存不足导致的页表创建失败
 *
 * 返回值：
 * - 0: 映射建立成功
 * - -E_NO_MEM: 内存分配失败
 *
 * ============================================================================
 * 使用场景
 * ============================================================================
 *
 * 1. 内存分配：malloc() 分配内存时建立映射
 * 2. 页面错误：缺页中断处理时建立映射
 * 3. 内存映射：mmap() 系统调用建立文件映射
 * 4. 共享内存：多个进程共享同一物理页
 */
int page_insert(pde_t *pgdir, struct Page *page, uintptr_t la, uint32_t perm)
{
    // ========================================================================
    // 第一步：获取或创建页表项
    // ========================================================================
    // 调用get_pte()查找目标地址的页表项，create=1表示允许分配中间页表
    // 如果页表分配失败，返回内存不足错误
    pte_t *ptep = get_pte(pgdir, la, 1);
    if (ptep == NULL)
    {
        return -E_NO_MEM;  // 页表分配失败，内存不足
    }

    // ========================================================================
    // 第二步：增加新页面的引用计数
    // ========================================================================
    // 在建立映射前，先增加目标页面的引用计数
    // 这是为了防止在处理映射冲突时出现引用计数错误
    page_ref_inc(page);

    // ========================================================================
    // 第三步：处理映射冲突
    // ========================================================================
    // 检查目标地址是否已被映射（页表项是否有效）
    if (*ptep & PTE_V)
    {
        // ====================================================================
        // 地址已被映射，找到当前映射的物理页
        // ====================================================================
        struct Page *p = pte2page(*ptep);

        if (p == page)
        {
            // ================================================================
            // 特殊情况：新页面与当前页面相同
            // ================================================================
            // 这是同一个物理页，只需要更新权限
            // 由于前面已经增加了引用计数，这里需要减回去
            // 最终引用计数不变（因为映射关系没有改变）
            page_ref_dec(page);
        }
        else
        {
            // ================================================================
            // 一般情况：不同物理页，需要解除旧映射
            // ================================================================
            // 调用page_remove_pte()解除旧的映射关系
            // 这会减少旧页面的引用计数，并在需要时释放页面
            page_remove_pte(pgdir, la, ptep);
        }
    }

    // ========================================================================
    // 第四步：建立新的映射关系
    // ========================================================================
    // 创建新的页表项：包含物理页号和权限标志
    // PTE_V | perm：有效位 + 用户指定的权限
    *ptep = pte_create(page2ppn(page), PTE_V | perm);

    // ========================================================================
    // 第五步：刷新TLB缓存
    // ========================================================================
    // 页表修改后必须刷新TLB，确保CPU使用新的映射关系
    // 不刷新会导致CPU仍使用旧的（或无效的）映射
    tlb_invalidate(pgdir, la);

    // ========================================================================
    // 返回成功
    // ========================================================================
    return 0;
}

/**
 * @brief 使指定的TLB条目失效
 *
 * TLB (Translation Lookaside Buffer) 是页表的高速缓存，用于加速虚拟地址到物理地址的转换。
 * 当页表内容发生变化时，必须刷新相应的TLB条目，确保CPU使用最新的映射关系。
 *
 * ============================================================================
 * TLB 工作原理
 * ============================================================================
 *
 * TLB 是内存管理单元 (MMU) 中的专用缓存，存储最近使用的虚拟地址到物理地址的映射：
 *
 * 1. **缓存结构**：每个条目包含 (虚拟页号 → 物理页号 + 权限)
 * 2. **查找过程**：VA → TLB查找 → 页表查找 → PA
 * 3. **性能提升**：TLB命中避免了访问内存中的页表
 *
 * ============================================================================
 * TLB 一致性问题
 * ============================================================================
 *
 * 当软件修改页表时，TLB中可能还缓存着旧的映射关系：
 *
 * ```c
 * // 软件修改页表
 * *ptep = new_mapping;
 *
 * // 但TLB中仍缓存着旧映射！
 * // CPU仍使用旧的物理地址
 * ```
 *
 * 这会导致：
 * - 访问错误的物理内存
 * - 数据不一致性
 * - 安全漏洞（访问不应访问的内存）
 *
 * ============================================================================
 * sfence.vma 指令详解
 * ============================================================================
 *
 * RISC-V 的 sfence.vma (Supervisor Fence Virtual Memory) 指令：
 *
 * 1. **作用**：刷新指定虚拟地址的TLB条目
 * 2. **语法**：sfence.vma rs1 (rs1 = 虚拟地址)
 * 3. **行为**：
 *    - 如果rs1 = 0：刷新所有TLB条目
 *    - 如果rs1 ≠ 0：只刷新指定地址的TLB条目
 *
 * 4. **内存屏障**：确保前面的内存写入对后续指令可见
 *
 * ============================================================================
 * 选择性刷新 vs 全局刷新
 * ============================================================================
 *
 * 代码注释中提到："The flush_tlb flush the entire TLB, is there any better way?"
 *
 * **全局刷新 (flush_tlb)**：
 * - 优点：简单，确保所有条目都被刷新
 * - 缺点：性能开销大，清空所有TLB缓存
 *
 * **选择性刷新 (sfence.vma)**：
 * - 优点：只刷新必要的条目，性能更好
 * - 缺点：需要知道具体的虚拟地址
 *
 * 在这个实现中选择 sfence.vma 是更好的选择，因为：
 * 1. 大多数情况下只修改一个页面的映射
 * 2. 减少不必要的TLB缓存失效
 * 3. 提高内存访问性能
 *
 * ============================================================================
 * 函数参数
 * ============================================================================
 *
 * @param pgdir  页目录基地址：用于识别是哪个地址空间的TLB
 *               (在RISC-V中，sfence.vma不使用这个参数)
 * @param la     线性地址：需要刷新的虚拟地址
 *
 * ============================================================================
 * 使用场景
 * ============================================================================
 *
 * 每当页表内容被修改后，都需要调用此函数：
 *
 * 1. **建立映射**：page_insert() 后刷新
 * 2. **解除映射**：page_remove_pte() 后刷新
 * 3. **修改权限**：更改页表项权限位后刷新
 * 4. **页面替换**：页替换算法修改映射后刷新
 *
 * ============================================================================
 * RISC-V 特有的考虑
 * ============================================================================
 *
 * 在RISC-V中：
 * - sfence.vma 指令是特权指令，只能在S模式或M模式执行
 * - 该指令会同步所有硬件线程的TLB（如果支持多核）
 * - 执行该指令会影响内存一致性
 */
void tlb_invalidate(pde_t *pgdir, uintptr_t la)
{
    // ========================================================================
    // 使用选择性TLB刷新指令
    // ========================================================================
    // sfence.vma la 只会刷新指定虚拟地址的TLB条目
    // 这比刷新整个TLB更高效，特别是对于单个页面操作
    asm volatile("sfence.vma %0" : : "r"(la));

    // ========================================================================
    // 注释中的全局刷新方案（未使用）
    // ========================================================================
    // flush_tlb(); // 这会刷新所有TLB条目，开销更大
    // 但在某些架构中可能是唯一选择
}

static void check_alloc_page(void)
{
    pmm_manager->check();
    cprintf("check_alloc_page() succeeded!\n");
}

static void check_pgdir(void)
{
    // assert(npage <= KMEMSIZE / PGSIZE);
    // The memory starts at 2GB in RISC-V
    // so npage is always larger than KMEMSIZE / PGSIZE
    size_t nr_free_store;

    nr_free_store = nr_free_pages();

    assert(npage <= KERNTOP / PGSIZE);
    assert(boot_pgdir_va != NULL && (uint32_t)PGOFF(boot_pgdir_va) == 0);
    assert(get_page(boot_pgdir_va, 0x0, NULL) == NULL);

    struct Page *p1, *p2;
    p1 = alloc_page();
    assert(page_insert(boot_pgdir_va, p1, 0x0, 0) == 0);

    pte_t *ptep;
    assert((ptep = get_pte(boot_pgdir_va, 0x0, 0)) != NULL);
    assert(pte2page(*ptep) == p1);
    assert(page_ref(p1) == 1);

    ptep = (pte_t *)KADDR(PDE_ADDR(boot_pgdir_va[0]));
    ptep = (pte_t *)KADDR(PDE_ADDR(ptep[0])) + 1;
    assert(get_pte(boot_pgdir_va, PGSIZE, 0) == ptep);

    p2 = alloc_page();
    assert(page_insert(boot_pgdir_va, p2, PGSIZE, PTE_U | PTE_W) == 0);
    assert((ptep = get_pte(boot_pgdir_va, PGSIZE, 0)) != NULL);
    assert(*ptep & PTE_U);
    assert(*ptep & PTE_W);
    assert(boot_pgdir_va[0] & PTE_U);
    assert(page_ref(p2) == 1);

    assert(page_insert(boot_pgdir_va, p1, PGSIZE, 0) == 0);
    assert(page_ref(p1) == 2);
    assert(page_ref(p2) == 0);
    assert((ptep = get_pte(boot_pgdir_va, PGSIZE, 0)) != NULL);
    assert(pte2page(*ptep) == p1);
    assert((*ptep & PTE_U) == 0);

    page_remove(boot_pgdir_va, 0x0);
    assert(page_ref(p1) == 1);
    assert(page_ref(p2) == 0);

    page_remove(boot_pgdir_va, PGSIZE);
    assert(page_ref(p1) == 0);
    assert(page_ref(p2) == 0);

    assert(page_ref(pde2page(boot_pgdir_va[0])) == 1);

    pde_t *pd1 = boot_pgdir_va, *pd0 = page2kva(pde2page(boot_pgdir_va[0]));
    free_page(pde2page(pd0[0]));
    free_page(pde2page(pd1[0]));
    boot_pgdir_va[0] = 0;
    flush_tlb();

    assert(nr_free_store == nr_free_pages());

    cprintf("check_pgdir() succeeded!\n");
}

static void check_boot_pgdir(void)
{
    size_t nr_free_store;
    pte_t *ptep;
    int i;

    nr_free_store = nr_free_pages();

    for (i = ROUNDDOWN(KERNBASE, PGSIZE); i < npage * PGSIZE; i += PGSIZE)
    {
        assert((ptep = get_pte(boot_pgdir_va, (uintptr_t)KADDR(i), 0)) != NULL);
        assert(PTE_ADDR(*ptep) == i);
    }

    assert(boot_pgdir_va[0] == 0);

    struct Page *p;
    p = alloc_page();
    assert(page_insert(boot_pgdir_va, p, 0x100, PTE_W | PTE_R) == 0);
    assert(page_ref(p) == 1);
    assert(page_insert(boot_pgdir_va, p, 0x100 + PGSIZE, PTE_W | PTE_R) == 0);
    assert(page_ref(p) == 2);

    const char *str = "ucore: Hello world!!";
    strcpy((void *)0x100, str);
    assert(strcmp((void *)0x100, (void *)(0x100 + PGSIZE)) == 0);

    *(char *)(page2kva(p) + 0x100) = '\0';
    assert(strlen((const char *)0x100) == 0);

    pde_t *pd1 = boot_pgdir_va, *pd0 = page2kva(pde2page(boot_pgdir_va[0]));
    free_page(p);
    free_page(pde2page(pd0[0]));
    free_page(pde2page(pd1[0]));
    boot_pgdir_va[0] = 0;
    flush_tlb();

    assert(nr_free_store == nr_free_pages());

    cprintf("check_boot_pgdir() succeeded!\n");
}

// perm2str - use string 'u,r,w,-' to present the permission
static const char *perm2str(int perm)
{
    static char str[4];
    str[0] = (perm & PTE_U) ? 'u' : '-';
    str[1] = 'r';
    str[2] = (perm & PTE_W) ? 'w' : '-';
    str[3] = '\0';
    return str;
}

// get_pgtable_items - In [left, right] range of PDT or PT, find a continuous
// linear addr space
//                  - (left_store*X_SIZE~right_store*X_SIZE) for PDT or PT
//                  - X_SIZE=PTSIZE=4M, if PDT; X_SIZE=PGSIZE=4K, if PT
// paramemters:
//  left:        no use ???
//  right:       the high side of table's range
//  start:       the low side of table's range
//  table:       the beginning addr of table
//  left_store:  the pointer of the high side of table's next range
//  right_store: the pointer of the low side of table's next range
//  return value: 0 - not a invalid item range, perm - a valid item range with
//  perm permission
static int get_pgtable_items(size_t left, size_t right, size_t start,
                             uintptr_t *table, size_t *left_store,
                             size_t *right_store)
{
    if (start >= right)
    {
        return 0;
    }
    while (start < right && !(table[start] & PTE_V))
    {
        start++;
    }
    if (start < right)
    {
        if (left_store != NULL)
        {
            *left_store = start;
        }
        int perm = (table[start++] & PTE_USER);
        while (start < right && (table[start] & PTE_USER) == perm)
        {
            start++;
        }
        if (right_store != NULL)
        {
            *right_store = start;
        }
        return perm;
    }
    return 0;
}
