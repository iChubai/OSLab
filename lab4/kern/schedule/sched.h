/**
 * @file kern/schedule/sched.h
 * @brief 进程调度器接口定义
 *
 * 本头文件定义了进程调度器的所有接口函数声明。
 * 调度器是操作系统中最核心的组件之一，负责管理CPU资源的分配。
 *
 * ============================================================================
 * 进程调度器的作用和重要性
 * ============================================================================
 *
 * 为什么需要进程调度器？
 * 1. 多道程序设计：计算机可以"同时"运行多个程序
 * 2. CPU资源有限：单处理器系统只有一个CPU核心
 * 3. 公平性：确保每个进程都能获得合理的CPU时间
 * 4. 响应性：及时响应用户输入和系统事件
 * 5. 效率：最大化CPU利用率，避免空闲等待
 *
 * ============================================================================
 * 调度器的基本工作原理
 * ============================================================================
 *
 * 调度时机（Scheduling Points）：
 * 1. 当前进程主动让出CPU（yield系统调用）
 * 2. 当前进程阻塞等待资源（I/O操作、信号量等）
 * 3. 定时器中断发生（时间片用完）
 * 4. 进程终止退出
 * 5. 更高优先级进程就绪
 *
 * 调度决策（Scheduling Decision）：
 * 1. 从就绪队列中选择下一个要运行的进程
 * 2. 进行进程上下文切换
 * 3. 更新进程状态和统计信息
 *
 * ============================================================================
 * 常见的调度算法
 * ============================================================================
 *
 * 1. 先进先出（FIFO/FCFS）：按到达顺序调度，先到先服务
 *    - 优点：简单公平
 *    - 缺点：短作业可能等待很长时间（护航效应）
 *
 * 2. 最短作业优先（SJF）：选择执行时间最短的作业
 *    - 优点：平均等待时间最短
 *    - 缺点：需要预知执行时间，长作业饥饿
 *
 * 3. 轮转调度（Round Robin）：每个进程获得固定时间片
 *    - 优点：公平、响应性好
 *    - 缺点：上下文切换开销
 *
 * 4. 优先级调度：根据优先级选择进程
 *    - 优点：重要进程优先执行
 *    - 缺点：可能导致低优先级进程饥饿
 *
 * 5. 多级队列调度：结合多种算法的混合调度
 *
 * ucore在lab4中使用的是简单的轮转调度算法。
 */

#ifndef __KERN_SCHEDULE_SCHED_H__
#define __KERN_SCHEDULE_SCHED_H__

#include <proc.h>  // 进程结构体定义

// ============================================================================
// 调度器核心接口
// ============================================================================

/**
 * @brief 执行进程调度 - 调度器的核心函数
 *
 * 这是整个调度系统的核心函数，负责在所有可运行进程中选择下一个要执行的进程。
 * 该函数实现了轮转调度（Round-Robin）算法，确保每个进程都能公平地获得CPU时间。
 *
 * 调度过程：
 * 1. 清除当前进程的重新调度标志
 * 2. 从进程就绪队列中选择下一个进程
 * 3. 如果需要，进行进程上下文切换
 * 4. 更新进程运行统计信息
 *
 * @note 该函数通常在以下情况下被调用：
 *       - 定时器中断（时间片用完）
 *       - 进程主动让出CPU
 *       - 进程从睡眠中被唤醒
 */
void schedule(void);

/**
 * @brief 唤醒睡眠进程 - 使进程重新可调度
 *
 * 将处于睡眠状态（PROC_SLEEPING）的进程转换为可运行状态（PROC_RUNNABLE），
 * 使其可以被调度器选中执行。这个函数是进程同步机制的重要组成部分。
 *
 * 唤醒场景：
 * - I/O操作完成
 * - 等待的资源变为可用
 * - 接收到信号
 * - 定时器到期
 *
 * @param proc 要唤醒的进程结构体指针
 *
 * @note 该函数不进行实际的调度，只是改变进程状态
 * @note 被唤醒的进程会在下次schedule()调用时被考虑
 */
void wakeup_proc(struct proc_struct *proc);

#endif /* !__KERN_SCHEDULE_SCHED_H__ */

