/**
 * @file kern/schedule/sched.c
 * @brief 进程调度器实现 - 实现轮转调度算法
 *
 * 本文件实现了ucore操作系统的进程调度器，这是操作系统中最核心的组件之一。
 * 调度器负责管理CPU资源的分配，确保多个进程能够公平、高效地共享CPU时间。
 *
 * ============================================================================
 * 轮转调度算法（Round-Robin Scheduling）
 * ============================================================================
 *
 * 核心思想：每个进程获得相等的时间片（time slice），轮流使用CPU。
 * 当一个进程的时间片用完时，调度器会切换到下一个就绪进程。
 *
 * 算法特点：
 * 1. 公平性：所有进程获得相同的时间片
 * 2. 简单性：实现和理解都比较简单
 * 3. 响应性：进程不会等待太长时间就能获得CPU
 * 4. 确定性：调度结果可预测
 *
 * 优点：
 * - 公平：每个进程都有平等的机会
 * - 响应快：适合交互式系统
 * - 简单：实现开销小
 *
 * 缺点：
 * - 上下文切换频繁：时间片太短会降低效率
 * - 不区分任务重要性：所有进程同等对待
 * - 平均等待时间较长：相比其他算法
 *
 * ============================================================================
 * 调度队列数据结构
 * ============================================================================
 *
 * ucore使用双向循环链表维护就绪进程队列：
 * - proc_list：全局进程链表，包含所有进程（除idle进程）
 * - 链表节点：通过proc_struct.list_link连接
 * - 遍历方式：从当前进程开始，寻找下一个PROC_RUNNABLE进程
 */

#include <list.h>       // 双向链表操作
#include <sync.h>       // 同步机制（中断控制）
#include <proc.h>       // 进程管理接口
#include <sched.h>      // 调度器接口定义
#include <assert.h>     // 断言，用于调试和正确性检查

// ============================================================================
// 进程状态管理函数
// ============================================================================

/* =====================================================================
 * 函数: wakeup_proc - 进程唤醒函数
 * 功能: 将睡眠状态的进程转换为可运行状态
 * 参数:
 *   proc - 要唤醒的进程结构体指针
 * 返回: void
 *
 * 详细说明:
 * 该函数是进程同步机制的核心组成部分，用于将等待某些条件的进程重新激活。
 *
 * 进程状态转换：
 *   PROC_SLEEPING -> PROC_RUNNABLE
 *
 * 唤醒场景示例：
 * 1. I/O操作完成：进程等待磁盘读取，现在数据已准备好
 * 2. 信号量释放：进程等待某个资源，现在资源可用
 * 3. 定时器到期：进程等待一定时间，现在时间已到
 * 4. 其他进程发信号：收到来自其他进程的通知
 *
 * 安全检查：
 * - 使用断言确保不会唤醒僵尸进程（已终止的进程）
 * - 确保不会重复唤醒已在可运行状态的进程
 *
 * 注意事项：
 * - 该函数只改变进程状态，不进行实际的调度
 * - 被唤醒的进程会在下次schedule()调用时被考虑执行
 * - 唤醒操作本身不会触发立即的上下文切换
 * ===================================================================== */
void
wakeup_proc(struct proc_struct *proc) {
    // ========== 安全检查 ==========
    // 确保进程处于合理的状态：不能是僵尸进程，也不能是已在运行的进程
    assert(proc->state != PROC_ZOMBIE && proc->state != PROC_RUNNABLE);

    // ========== 状态转换 ==========
    // 将进程状态从睡眠转换为可运行，等待调度器选中
    proc->state = PROC_RUNNABLE;
}

// ============================================================================
// 进程调度器
// ============================================================================

/* =====================================================================
 * 函数: schedule - 轮转调度算法的核心实现
 * 功能: 从就绪队列中选择下一个要执行的进程并进行切换
 * 参数: void
 * 返回: void
 *
 * 详细说明:
 * 这是ucore调度系统的核心函数，实现了经典的轮转调度算法。
 * 该算法确保所有就绪进程都能公平地获得CPU时间，实现多道程序的并发执行。
 *
 * ============================================================================
 * 轮转调度算法的工作流程
 * ============================================================================
 *
 * 1. 原子性保证：关闭中断，确保调度过程不被打断
 * 2. 清除调度标志：重置当前进程的need_resched标志
 * 3. 确定搜索起点：实现真正的轮转（round-robin）
 * 4. 遍历查找：寻找下一个可运行的进程
 * 5. 容错处理：如果没有就绪进程，选择idle进程
 * 6. 统计更新：记录进程的运行次数
 * 7. 上下文切换：切换到选中的进程执行
 * 8. 恢复状态：重新开启中断
 *
 * ============================================================================
 * 轮转调度策略详解
 * ============================================================================
 *
 * 搜索策略：
 * - 从"当前进程的下一个"开始查找（不是从头开始）
 * - 这确保了真正的轮转：每个进程执行完时间片后，下次从它后面开始
 * - idle进程特殊处理：从链表头开始，避免idle进程占用过多CPU时间
 *
 * 公平性保证：
 * - 所有PROC_RUNNABLE进程都有平等的机会
 * - 按链表顺序轮流执行，没有优先级区分
 * - 每个进程都获得相同的CPU时间片（由定时器中断控制）
 *
 * 容错机制：
 * - 如果遍历完所有进程仍未找到就绪进程，选择idle进程
 * - idle进程始终可运行，确保系统不会死机
 * - 即使在极端情况下，CPU也会有事情做（执行idle循环）
 *
 * ============================================================================
 * 与定时器中断的配合
 * ============================================================================
 *
 * 轮转调度的关键在于时间片的控制：
 * 1. 每个进程获得固定时间片（在ucore中由TICK_NUM控制）
 * 2. 时间片用完时，定时器中断触发
 * 3. 中断处理函数设置need_resched标志
 * 4. 中断返回时，如果need_resched为真，调用schedule()
 * 5. schedule()选择下一个进程，完成切换
 *
 * 这种设计实现了"抢占式多任务"：进程不能无限占用CPU。
 * ===================================================================== */
void
schedule(void) {
    bool intr_flag;                    // 用于保存和恢复中断状态
    list_entry_t *le, *last;          // 链表遍历指针
    struct proc_struct *next = NULL;   // 选中的下一个要执行的进程

    // ========== 1. 关闭中断，确保调度原子性 ==========
    // 调度是关键操作，不能被中断打断，否则可能导致数据结构不一致
    local_intr_save(intr_flag);
    {
        // ========== 2. 清除调度请求标志 ==========
        // 当前进程的调度请求已得到处理，重置标志
        current->need_resched = 0;

        // ========== 3. 确定搜索起始点 ==========
        // 实现轮转调度的关键：从当前进程之后开始查找
        // 如果当前是idle进程，从链表头开始（避免idle进程连续执行）
        last = (current == idleproc) ? &proc_list : &(current->list_link);
        le = last;

        // ========== 4. 遍历进程链表，寻找可运行进程 ==========
        do {
            // 获取链表中的下一个节点
            if ((le = list_next(le)) != &proc_list) {
                next = le2proc(le, list_link);

                // 检查进程状态：只有PROC_RUNNABLE的进程才能被调度
                if (next->state == PROC_RUNNABLE) {
                    break;  // 找到目标进程，跳出循环
                }
            }
        } while (le != last);  // 确保只遍历一圈，避免无限循环

        // ========== 5. 容错处理：确保始终有进程可执行 ==========
        // 如果没有找到可运行进程（理论上不太可能），选择idle进程
        if (next == NULL || next->state != PROC_RUNNABLE) {
            next = idleproc;  // idle进程始终可用，作为最后的fallback
        }

        // ========== 6. 更新进程运行统计 ==========
        // 记录该进程被调度的次数，用于性能监控和调试
        next->runs ++;

        // ========== 7. 执行进程切换 ==========
        if (next != current) {
            // 需要切换到不同的进程
            proc_run(next);
        }
        // 如果选中进程就是当前进程，继续执行（不需要切换）
    }
    // ========== 8. 恢复中断状态 ==========
    // 调度完成，重新允许中断
    local_intr_restore(intr_flag);
}

