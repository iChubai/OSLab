/**
 * @file kern/schedule/sched.c
 * @brief 进程调度器实现
 *
 * 本文件实现了ucore操作系统的进程调度器，包括：
 * - 进程唤醒功能
 * - 简单的轮转调度算法
 * - 调度器接口
 */

#include <list.h>       // 双向链表操作
#include <sync.h>       // 同步机制
#include <proc.h>       // 进程管理
#include <sched.h>      // 调度器接口
#include <assert.h>     // 断言

// ============================================================================
// 进程状态管理函数
// ============================================================================

/* =====================================================================
 * 函数: wakeup_proc
 * 功能: 将进程从睡眠状态唤醒为可运行状态
 * 参数:
 *   proc - 要唤醒的进程指针
 * 返回: void
 *
 * 说明:
 * 该函数将进程状态从睡眠状态（PROC_SLEEPING）转换为可运行状态（PROC_RUNNABLE），
 * 使得该进程可以被调度器选中执行。
 *
 * 注意：
 * - 不能唤醒僵尸进程（PROC_ZOMBIE）
 * - 不能重复唤醒已在可运行状态的进程
 * ===================================================================== */
void
wakeup_proc(struct proc_struct *proc) {
    // 断言：确保进程不在僵尸状态或可运行状态
    assert(proc->state != PROC_ZOMBIE && proc->state != PROC_RUNNABLE);

    // 设置进程为可运行状态
    proc->state = PROC_RUNNABLE;
}

// ============================================================================
// 进程调度器
// ============================================================================

/* =====================================================================
 * 函数: schedule
 * 功能: 执行进程调度，选择下一个要执行的进程
 * 参数: void
 * 返回: void
 *
 * 详细说明:
 * 该函数实现了简单的轮转调度（Round-Robin）算法：
 * 1. 从当前进程的下一个进程开始查找可运行进程
 * 2. 如果当前进程是idle进程，则从进程链表头开始查找
 * 3. 遍历进程链表，寻找第一个处于可运行状态的进程
 * 4. 如果没有找到可运行进程，则选择idle进程
 * 5. 增加选中进程的运行次数计数
 * 6. 如果选中进程不是当前进程，则进行进程切换
 *
 * 调度策略：
 * - 采用轮转方式：每个进程都有平等的机会获得CPU
 * - 优先级相同的进程按链表顺序轮流执行
 * - idle进程作为fallback，确保系统不会没有可执行进程
 * ===================================================================== */
void
schedule(void) {
    bool intr_flag;                    // 保存中断状态
    list_entry_t *le, *last;          // 链表遍历指针
    struct proc_struct *next = NULL;   // 选中的下一个进程

    // 关闭中断，保证调度过程的原子性
    local_intr_save(intr_flag);
    {
        // 清除当前进程的重新调度标志
        current->need_resched = 0;

        // ========== 确定查找起始点 ==========
        // 如果当前是idle进程，从链表头开始查找
        // 否则从当前进程的下一个开始查找（实现轮转调度）
        last = (current == idleproc) ? &proc_list : &(current->list_link);
        le = last;

        // ========== 查找下一个可运行进程 ==========
        do {
            // 获取下一个链表节点
            if ((le = list_next(le)) != &proc_list) {
                next = le2proc(le, list_link);

                // 找到第一个可运行状态的进程
                if (next->state == PROC_RUNNABLE) {
                    break;  // 找到目标，跳出循环
                }
            }
        } while (le != last);  // 遍历完一圈后停止

        // ========== 处理未找到可运行进程的情况 ==========
        // 如果没找到可运行进程或者找到的进程状态不对，选择idle进程
        if (next == NULL || next->state != PROC_RUNNABLE) {
            next = idleproc;
        }

        // ========== 更新进程运行统计 ==========
        next->runs ++;  // 增加选中进程的运行次数计数

        // ========== 执行进程切换 ==========
        if (next != current) {
            proc_run(next);  // 切换到选中进程
        }
        // 如果选中进程就是当前进程，则继续执行（不需要切换）
    }
    // 恢复中断状态
    local_intr_restore(intr_flag);
}

