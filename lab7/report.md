# Lab7 实验报告

## 练习0：填写已有实验
本次在 `lab7/kern/process/proc.c` 中补齐进程创建与上下文切换、ELF 装载返回用户态的关键字段初始化，并在 `lab7/kern/mm/pmm.c` 中完成 `copy_range` 的页内容复制与页表映射；同时将调度器相关实现补齐到 `lab7/kern/schedule/default_sched.c` 与 `lab7/kern/schedule/default_sched_stride.c`，保证与前序实验的进程管理与调度语义一致。这样可以让后续同步原语与测试线程正常运行，构成 lab7 的基础依赖链。

## 练习1：理解内核级信号量与哲学家就餐（不编码）
内核信号量实现位于 `lab7/kern/sync/sem.c`，核心结构为 `semaphore_t`，包含计数值与等待队列。`down` 在计数大于 0 时原子减一并返回；否则把当前进程挂入等待队列并进入调度，`up` 则优先唤醒等待队列中的一个线程，否则增加计数。实现通过关中断保证检查与队列操作原子性，再结合 `wait_queue` 与 `schedule` 实现阻塞/唤醒流程。

哲学家问题在 `lab7/kern/sync/check_sync.c` 中采用“互斥锁 + 每人一个信号量”的方案：`mutex` 保护状态数组，`phi_take_forks_sema` 只在持有 `mutex` 的临界区内检查邻居并设置状态，随后释放 `mutex` 再在自己的信号量上阻塞，`phi_put_forks_sema` 在临界区内更新状态并唤醒左右邻居。此方案不会死锁的关键原因是：拿叉子过程被抽象为对状态的原子检查与授予，不存在“拿到一只叉子再等待另一只”的占有与等待环路；同时每次阻塞前都释放 `mutex`，且只有当左右都不在吃时才允许进入 EATING，从而打破循环等待条件。

用户态信号量机制可以提供 `sys_sem_init/sys_sem_wait/sys_sem_post` 等系统调用，用户态 `sem_t` 只保存内核对象句柄或共享内存中的计数并通过内核进行睡眠/唤醒。与内核级信号量相同点在于都需要原子化的计数变化与等待队列语义，不同点在于用户态需要跨地址空间的参数校验与对象管理，并承担更多的系统调用开销；内核态信号量则直接操纵调度与等待队列，路径更短但只服务内核代码。

## 练习2：内核级条件变量与哲学家就餐（编码）
内核条件变量通过管程语义实现，结构体 `monitor_t` 含 `mutex`、`next` 与 `next_count`，条件变量 `condvar_t` 含 `sem` 与等待计数，实现见 `lab7/kern/sync/monitor.c`。`cond_wait` 先增加等待计数，再释放管程互斥（优先唤醒 `next`，否则释放 `mutex`），随后在条件变量信号量上阻塞；`cond_signal` 若有等待者则进入 Hoare 语义的“立即交接”流程：唤醒等待线程并在 `next` 上等待对方离开管程。此设计保证被唤醒线程在信号后立即拥有管程。

哲学家问题的条件变量版本位于 `lab7/kern/sync/check_sync.c`：`phi_take_forks_condvar` 在管程中设置 HUNGRY 并调用 `phi_test_condvar`，若条件未满足则在自身条件变量上等待；`phi_put_forks_condvar` 将自身置为 THINKING 并测试左右邻居，满足条件时 `cond_signal` 唤醒。该流程与信号量版本的核心差异在于“等待条件”由条件变量表达，互斥由管程统一维护。

用户态条件变量机制可以沿用 `pthread_cond` 风格：`cond_wait` 必须与用户互斥锁配对，内部通过内核等待队列或轻量 futex 唤醒。与内核级条件变量相同点是“等待/唤醒 + 与互斥锁配对”的语义，不同点是用户态需要显式系统调用或 futex 进入内核、并处理跨地址空间的线程阻塞。

关于“条件变量能否不基于信号量”：可以不直接依赖信号量，只要内核提供可睡眠等待队列与原子化的锁/解锁操作，就能用“等待队列 + 互斥锁 + 直接睡眠/唤醒”实现条件变量；但如果内核仅提供信号量作为唯一阻塞原语，则条件变量通常需要借助信号量完成等待与唤醒。

## 扩展练习（设计说明）
Challenge 1（死锁与重入探测）可通过维护“等待图”实现：资源（锁/信号量）与进程构成二分图，线程在阻塞时记录等待边，释放时删除边；每次阻塞前对等待图做一次环检测，若出现环则进入 monitor 并输出涉及的进程/资源链。重入探测可在锁结构里记录 owner 与重入计数，同时在“进入临界区”路径做校验，若发现非 owner 进入则记录并触发告警。

Challenge 2（简化 RCU）可设计为全局 epoch + 读者计数：`rcu_read_lock/unlock` 增减本地读者计数，写者更新指针后将旧对象加入回收链表，启动一次“宽限期”扫描，等待所有读者计数归零后再回收。测试用例可用多个读线程频繁读取共享指针，写线程更新并延迟释放，验证无悬挂指针与无阻塞读路径。

## 重要知识点与 OS 原理对应
本实验的关键知识点包括：内核信号量的计数与等待队列（对应 OS 原理中的同步原语与临界区互斥）、管程与条件变量的 Hoare 语义（对应高级同步结构）、哲学家就餐中的死锁必要条件与避免策略（对应死锁理论）。从实现角度看，`lab7/kern/sync/sem.c` 与 `lab7/kern/sync/monitor.c` 体现了“阻塞/唤醒 + 原子性”的内核级调度支撑，而 `lab7/kern/sync/check_sync.c` 给出了经典同步问题的工程化落地。

## OS 原理中重要但实验未覆盖的知识点
实验未直接覆盖的关键内容包括：死锁的检测/恢复策略（银行家算法与资源回收）、优先级反转与优先级继承、内存一致性模型与多核同步、文件系统日志与崩溃恢复、I/O 调度与设备驱动模型等。这些内容在 OS 原理中同样重要，但本实验侧重于内核级同步与调度基础机制。
